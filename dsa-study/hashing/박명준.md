# 해쉬(Hash)

해쉬는 "키-값(key-value)" 쌍으로 데이터를 저장하는 구조입니다.  
특정 키를 입력하면, 그에 해당하는 값을 빠르게 찾을 수 있도록 해주는 자료 구조입니다.

> **해시**란 "해시 함수" + "해시 테이블"을 활용한 저장/탐색 방법

```js
// 간단한 예시
{
  "apple": "사과",
  "banana": "바나나",
  "orange": "오렌지"
}
```

`"apple"`이라는 **키**로 "사과"라는 **값**을 빠르게 찾을 수 있습니다.

## 해쉬를 사용하는 이유

- **탐색, 삽입 삭제가 빠르다**: 평균적으로 **O(1)**의 시간복잡도를 가진다. (즉, 한 번에 접근 가능)
- 빈도 수 세기, 중복 제거, 관계 매핑 등에 자주 사용됨

## 📚 Map

자바스크립트에서 객체(Object)는 여러 형태의 데이터를 손쉽게 묶을 수 있는 아주 편리하고 손쉬운 자료구조입니다.

```js
const map = new Map();
map.set('apple', '사과');
map.set(123, '숫자 키');

console.log(map.get('apple')); // "사과"
console.log(map.get(123)); // "숫자 키"
```

- 키 타입이 문자열, 숫자, 객체 등 제한 없음
- 순서를 보장(`for...of`로 순회 가능)

### Map 메서드 정리

| 메서드            | 설명                      | 예시                                |
| ----------------- | ------------------------- | ----------------------------------- |
| `set(key, value)` | 🔥키에 값 저장            | `map.set('id', 100)`                |
| `get(key)`        | 🔥키에 해당하는 값 반환   | `map.get('id') → 100`               |
| `has(key)`        | 🔥해당 키가 존재하는지    | `map.has('id') → true`              |
| `delete(key)`     | 🔥해당 키-값 삭제         | `map.delete('id')`                  |
| `clear()`         | 🔥모든 항목 제거          | `map.clear()`                       |
| `size`            | 전체 항목 개수            | `map.size`                          |
| `keys()`          | 모든 키 반환 (이터레이터) | `for (let k of map.keys())`         |
| `values()`        | 모든 값 반환              | `for (let v of map.values())`       |
| `entries()`       | \[key, value] 쌍 반환     | `for (let [k, v] of map.entries())` |
| `forEach(cb)`     | 반복 실행                 | `map.forEach((v, k) => ...)`        |

## `Set`도 해시인가?

`Set`은 해시지만 목적과 구조가 다릅니다.

`Set`은 값만 저장하지만, 내부에서는 그 값을 키처럼 처리해서 빠르게 존재 여부를 판단합니다.  
즉, 값을 키로 보고 해시 함수를 적용해서 저장/탐색하는 구조입니다.

> `Set`도 해시 기반 구조입니다.
> 하지만 `Map`처럼 키-값 쌍을 저장하지는 않습니다.
>
> 중복 없이 유일한 값만 저장
> 자주 쓰이는 용도: 중복 제거

## 해시 테이블과 해시 함수

해시라는 개념에서 빠질 수 없는 두 핵심 요소가 **해시 테이블**, **해시 함수**입니다.

### 해시 테이블(Hash Table)

해시 테이블은 배열과 비슷한 자료구조로,  
키를 이용해 데이터를 저장하고 찾을 수 있도록 설계된 고속 조회용 테이블입니다.

즉, 해시 테이블은 내부적으로 **배열** 같은 공간을 만들어놓고  
특정 "키"를 넣었을 때 이 키가 저장될 위치(인덱스)를 **해시 함수**로 결정합니다.

### 해시 함수(Hash Function)란?

해시 함수는 키(key)를 숫자(인덱스)로 변환하는 함수입니다.

👉 문자열/객체/숫자 등 어떤 종류의 키든 해시 테이블의 **인덱스 범위 안에서 유일한 숫자(index)**로 바꿔주는 역할

#### 요약

- 해시 함수: "키"를 숫자로 변환 -> 인덱스 위치 계산
- 해시 테이블: 해시 함수가 정한 위치에 값을 저장/조회

## 💣 해시 충돌(Hash Collision)은?

서로 다른 키가 **같은 해시 값(인덱스)**을 갖는 상황을 말합니다.

> 해시 함수 특성상 키가 무한해도 배열의 인덱스(공간)는 유한함
>
> 그래서 어떤 키든 해시 함수가 제한된 공간 안에서 인덱스를 만들어야 하므로 충돌은 언젠가는 무조건 발생할 수 밖에 없습니다.

> ✔ 좋은 해시 함수란?
> **충돌을 최대한 줄이는 해시 함수가 좋은 해시 함수입니다.**

### ✨ 해시 충돌 해결 방법

충돌이 발생한 경우를 대비한 전략의 대표적인 2가지 방법은

1. **체이닝(Chaining)**

같은 인덱스에 여러 개의 값을 배열(혹은 연결 리스트)로 묶어서 저장

- 충돌이 많이 나도 계속 저장 가능
- 구조가 직관적임
- 배열/리스트를 순회해야 하므로 O(1)보다는 느려질 수 있음

2. **오픈 어드레싱(Open Addressing)**

충돌이 발생하면, 테이블 내의 다음 빈 자리를 찾아 저장

- 공간 낭비가 적음
- 구조가 단순
- 충돌이 많아지면 탐색 속도가 느려짐
- 삭제가 까다로움

#### 대표 기법:

- 선형 탐사(Linear Probing): 다음 칸, 그 다음 칸 순서대로 찾기
- 이차 탐사(Quadratic Probing): 1, 4, 9 거리로 찾아가기
- 더블 해싱(Double Hashing): 2개의 해시 함수를 이용해서 다음 위치 계산

> 자바스크립트에서는
> `Map`, `Set`, `Object`는 브라우저 엔진 내부에서 충돌 처리를 다 해줍니다.
> 쉽게 `map.set(k, v)` 혹은 `set.add(v)`만 쓰면 된다.
> 내부에서 체이닝 방식을 사용하는 경우가 많다.
