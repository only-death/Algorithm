# 📚 스택(Stack)

스택은 **LIFO(Last-In, First-Out)** 구조를 가진 **선형 자료구조**입니다.  
가장 나중에 들어온 데이터가 가장 먼저 나가는 구조입니다.

## 주요 연산

| 연산         | 설명                                    |
| ------------ | --------------------------------------- |
| `push(item)` | 아이템을 스택의 맨 위에 추가            |
| `pop()`      | 맨 위 아이템을 꺼내서 제거              |
| `peek()`     | 맨 위 아이템을 보기만 하고 제거는 안 함 |
| `isEmpty()`  | 스택이 비었는지 확인                    |
| `size()`     | 스택 안에 있는 아이템 수                |

## 이런 구조의 예시

### 웹 브라우저의 '뒤로 가기' 기능

1. 사용자가 방문한 페이지는 순서대로 스택에 저장됩니다.

2. 뒤로 가기를 누르면 가장 마지막에 방문한 페이지부터 꺼냅니다.

3. 순서대로 꺼낼 필요 없음 -> "마지막에 본 페이지부터 먼저 나가야 하므로" **스택 구조**임

```scss
[구글 → 네이버 → 유튜브]
                    ↑
    (현재 페이지/마지막에 들어온 페이지)

pop() → 유튜브 꺼냄 → 네이버로 이동
```

## 사용되는 실제 사례

| 사용 사례                        | 설명                                                    |
| -------------------------------- | ------------------------------------------------------- |
| **재귀 호출 처리(Call Stack)**   | JS의 `call stack`은 스택 구조                           |
| **웹 브라우저 뒤로/앞으로 가기** | 페이지 방문 기록 저장에 사용                            |
| **문자열 뒤집기**                | 한 글자씩 넣고 꺼내면 순서 반대                         |
| **괄호 짝 검사**                 | 여는 괄호를 스택에 넣고 닫는 괄호가 올 때 맞는지 비교   |
| **DFS (깊이 우선 탐색)**         | 탐색 루트를 따라가고, 막히면 다시 돌아옴 (Backtracking) |

### 대표 예제 - 괄호 짝 검사

> 문자열에 괄호가 올바르게 닫혔는지 검사하라.  
> 예: `(()())` → true, `(())(` → false

#### 해결 방식

- 여는 괄호 `(`가 오면 스택에 push
- 닫는 괄호 `)`가 오면 스택에서 pop
- 다 끝났을 때 스택이 비어있으면 올바르게 닫힌 경우!

```js
function isValidParentheses(str) {
  const stack = [];

  for (let char of str) {
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.pop() !== '(') return false;
    }
  }

  return stack.length === 0;
}
```

# 🎢 큐(Queue)

큐는 **FIFO(Firs-In, First-Out)** 구조를 가진 **선형 자료구조**입니다.  
먼저 들어온 데이터가 먼저 나감

## 예시

- 은행 번호표: 먼저 온 사람이 먼저 처리됨
- 놀이공원 줄: 먼저 선 사람이 먼저 탐
- 프린터 대기열: 먼저 요청한 문서부터 출력됨

> "줄서기" 같은 개념

```css
[ A, B, C ]  ← A 먼저 들어오고
  ↑            A 먼저 나감
Front   Rear
```

## 가능한 연산

| 연산            | 설명                                         |
| --------------- | -------------------------------------------- |
| `enqueue(item)` | 아이템을 큐의 **뒤(Rear)** 에 추가           |
| `dequeue()`     | 큐의 **앞(Front)** 에서 아이템 제거하고 반환 |
| `peek()`        | 큐의 앞 아이템을 확인만 (제거 X)             |
| `isEmpty()`     | 큐가 비어있는지 확인                         |
| `size()`        | 큐에 들어 있는 요소 개수 확인                |

## 🔥 큐가 필요한 이유

#### 비동기 처리나 순서 보장이 필요한 경우 사용

- 이벤트 처리기: 먼저 들어온 이벤트부터 처리
- 멀티스레드 작업 큐: 작업 순서대로 실행해야 함

### 브라우저 예시

`setTimeout`, `setInterval`, `Promise` -> 이벤트 루프와 **태스크 큐**가 관련됨

### 사용되는 실제 사례

| 유형                     | 설명                              |
| ------------------------ | --------------------------------- |
| **BFS (너비 우선 탐색)** | 그래프 탐색 시 큐 사용            |
| **캐시 구현**            | LRU Cache 등                      |
| **시뮬레이션 문제**      | 줄 서기, 회전, 턴제 시스템        |
| **최단거리 구하기**      | BFS로 최단 거리 계산할 때 큐 사용 |

# 🔍 스택 vs 큐

| 항목   | 스택(Stack)               | 큐(Queue)                         |
| ------ | ------------------------- | --------------------------------- |
| 구조   | LIFO                      | FIFO                              |
| 예시   | 함수 호출 스택            | BFS, 대기열                       |
| 삽입   | 맨 위에 추가              | 뒤에 추가                         |
| 제거   | 맨 위에서 제거            | 앞에서 제거                       |
| 사용처 | 재귀, 백트래킹, 괄호 검사 | 시뮬레이션, 최단거리, 이벤트 순서 |
