# 정렬 알고리즘 이론 완전 정복 📚

## 🎯 정렬의 기본 개념

**정렬(Sorting)**이란 주어진 데이터를 특정 기준에 따라 순서대로 배열하는 과정이다. 컴퓨터 과학에서 가장 기본적이면서도 중요한 알고리즘 중 하나이다.

### 정렬의 분류 기준

**안정성(Stability)에 따른 분류:**

- **안정 정렬**: 동일한 값을 가진 요소들의 상대적 순서가 정렬 후에도 유지되는 정렬이다
- **불안정 정렬**: 동일한 값을 가진 요소들의 상대적 순서가 정렬 과정에서 바뀔 수 있는 정렬이다

**메모리 사용에 따른 분류:**

- **제자리 정렬(In-place)**: 추가 메모리 공간을 거의 사용하지 않는 정렬이다 (O(1) 공간복잡도)
- **외부 정렬(Out-of-place)**: 추가 메모리 공간을 필요로 하는 정렬이다

## 📊 시간복잡도 이론

### O(n²) 정렬 알고리즘들

**버블 정렬(Bubble Sort)**

- 인접한 두 원소를 비교하여 교환하는 방식이다
- 가장 큰 원소가 매 패스마다 맨 뒤로 "거품처럼 떠오르는" 모습에서 이름이 유래되었다
- 최선의 경우에도 O(n²)이지만, 최적화 시 이미 정렬된 배열에서는 O(n)이다

**선택 정렬(Selection Sort)**

- 매번 최솟값(또는 최댓값)을 찾아 맨 앞으로 보내는 방식이다
- 항상 정확히 n(n-1)/2번의 비교를 수행하므로 최선, 평균, 최악이 모두 O(n²)이다
- 교환 횟수가 최대 n-1번으로 제한되어 있다는 특징이 있다

**삽입 정렬(Insertion Sort)**

- 각 원소를 이미 정렬된 부분에서 적절한 위치에 삽입하는 방식이다
- 이미 정렬된 배열에서는 O(n)의 최고 성능을 보인다
- 작은 크기의 배열이나 거의 정렬된 배열에 매우 효율적이다

### O(n log n) 정렬 알고리즘들

**병합 정렬(Merge Sort)**

- 분할 정복(Divide and Conquer) 패러다임을 사용하는 대표적인 알고리즘이다
- 항상 O(n log n)의 안정적인 성능을 보장한다
- 안정 정렬이며, 연결 리스트 정렬에 특히 적합하다
- 단점은 O(n)의 추가 메모리가 필요하다는 점이다

**퀵 정렬(Quick Sort)**

- 피벗(pivot)을 기준으로 분할하는 분할 정복 알고리즘이다
- 평균적으로 O(n log n)이지만 최악의 경우 O(n²)가 될 수 있다
- 제자리 정렬이 가능하여 메모리 효율적이다
- 피벗 선택 전략이 성능에 큰 영향을 미친다

**힙 정렬(Heap Sort)**

- 힙 자료구조를 이용한 정렬 알고리즘이다
- 항상 O(n log n)의 성능을 보장하며 제자리 정렬이다
- 불안정 정렬이지만 최악의 경우에도 성능이 보장된다는 장점이 있다

## 🧮 복잡도 분석의 핵심

### 점근적 표기법의 의미

**Big O 표기법**은 알고리즘의 상한선을 나타낸다. 즉, "최악의 경우에도 이 시간을 넘지 않는다"는 보장이다.

**Θ(theta) 표기법**은 평균적인 성능을 나타내며, 상한과 하한이 같을 때 사용된다.

**Ω(omega) 표기법**은 알고리즘의 하한선을 나타낸다.

### 정렬의 이론적 한계

**비교 기반 정렬의 하한선**은 O(n log n)이다. 이는 정보 이론적으로 증명된 사실이다.

n개의 원소를 정렬하기 위해서는 최소 log₂(n!) ≈ n log n번의 비교가 필요하다.

따라서 병합 정렬과 힙 정렬은 이론적으로 최적에 가까운 알고리즘이다.

## 🎲 비교 기반이 아닌 정렬들

**계수 정렬(Counting Sort)**

- 각 원소의 개수를 세어서 정렬하는 방식이다
- O(n + k) 시간복잡도를 가진다 (k는 데이터 범위)
- 정수나 제한된 범위의 데이터에만 적용 가능하다

**기수 정렬(Radix Sort)**

- 자릿수별로 정렬을 수행하는 방식이다
- O(d × (n + k)) 시간복잡도를 가진다 (d는 자릿수)
- 문자열이나 고정 크기 정수 정렬에 효과적이다

**버킷 정렬(Bucket Sort)**

- 데이터를 여러 버킷으로 분산시켜 정렬하는 방식이다
- 평균적으로 O(n + k) 성능을 보인다
- 데이터가 균등하게 분포될 때 효과적이다

## 🏆 실제 상황에서의 선택 기준

**작은 데이터 크기 (n < 50)**

- 삽입 정렬이 가장 효율적이다
- 오버헤드가 적고 구현이 간단하다

**일반적인 상황**

- 퀵 정렬이나 내장 정렬 함수를 사용한다
- 대부분의 언어에서 하이브리드 정렬을 구현하고 있다

**안정성이 중요한 경우**

- 병합 정렬을 선택한다
- 데이터베이스 정렬이나 다중 키 정렬에 필수적이다

**메모리가 제한적인 경우**

- 힙 정렬이나 퀵 정렬을 사용한다
- 제자리 정렬의 장점을 활용할 수 있다

## 💡 하이브리드 정렬의 지혜

**Introsort (Introspective Sort)**

- 퀵 정렬로 시작하여 깊이가 깊어지면 힙 정렬로 전환한다
- 작은 부분배열에서는 삽입 정렬을 사용한다
- 최악의 경우 O(n log n)을 보장하면서도 평균적으로 빠르다

**Timsort**

- 실제 데이터의 패턴을 활용하는 적응적 정렬이다
- 이미 정렬된 부분(run)을 찾아 효율적으로 병합한다
- Python과 Java에서 기본 정렬로 사용된다

## 🎯 핵심 정리

정렬 알고리즘 선택은 데이터의 특성, 메모리 제약, 안정성 요구사항을 종합적으로 고려해야 한다.

이론적 한계를 이해하면 알고리즘의 개선 가능성을 판단할 수 있다.

실제 구현에서는 단일 알고리즘보다 하이브리드 접근법이 더 효과적이다.

비교 기반 정렬의 O(n log n) 한계를 넘어서려면 데이터의 특수한 성질을 활용해야 한다.
