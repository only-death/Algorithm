### 2025.06.15 스프린트 플래닛 스터디 4

# 정렬

### 정렬 정리 -> https://yoolllog.tistory.com/50

## 정렬을 활용한 알고리즘 문제 예시

1. 배열 오름차순 정렬

```javascript
const arr = [5, 2, 8, 1, 3];
arr.sort((a, b) => a - b);
console.log(arr); // [1, 2, 3, 5, 8]
```

2. 배열 내 중복 제거 후 정렬

```javascript
const arr = [4, 2, 2, 1, 3, 3];
const uniqueSorted = [...new Set(arr)].sort((a, b) => a - b);
console.log(uniqueSorted); // [1, 2, 3, 4]
```

## 전략 정리

- 배열이 짧거나 거의 정렬돼 있다 → 삽입 정렬

- 큰 데이터셋 → 퀵 정렬 또는 병합 정렬

- 정수 범위가 좁다 → 카운팅 정렬

- 정렬 + 중복 제거가 필요하다 → Set + 정렬

- 안정성 보장이 필요하다 → 병합 정렬 / 카운팅 정렬

**정렬과 관련된 실전 사용 예**

- 검색 엔진: 결과 정렬 (정확도, 최신순 등)

- 전자상거래: 가격순, 평점순 정렬

- 시간표 생성기: 시간대 기준 정렬

- 게임: 랭킹 정렬

- 데이터 분석: 통계, 그룹화, 집계의 전처리

## 정렬을 대신할만한 다른 방법이 있나?

정렬은 매우 강력한 도구지만, 모든 상황에서 꼭 정렬이 필요한 건 아님님. 문제의 목적에 따라 더 빠르고 효과적인 대체 방법이 존재할 수 있음

### 1. 우선순위 큐 / 힙 (Heap)

✔ 언제 사용?

- K번째 최소/최대값, 가장 작은/큰 값 유지, 실시간 정렬 필요할 때

- 정렬 후 사용하는 알고리즘을 실시간 처리로 대체할 수 있음

✔ 장점:

- 삽입/삭제 O(log n)

- 실시간 처리에 유리

✔ 단점:

- 전체 정렬된 상태는 아님 (peek만 정렬 기준 유지)

### 2. Set / Map을 이용한 정렬 목적 대체

✔ 언제 사용?

- 중복 제거, 존재 여부 확인, 빠른 삽입/탐색이 필요한 경우

✔ 장점:

- O(1)에 가까운 탐색, 삽입

- 정렬 없이도 원하는 정보 처리 가능

✔ 단점:

- 순서 정보는 유지되지 않음

### 3. 투 포인터 기법 (Two Pointers)

✔ 언제 사용?

- 정렬 후 정답을 찾는 패턴을 미리 정렬된 상태로 가정하거나 정렬 없이 처리 가능할 때

- 예: 정렬 없이 두 포인터가 범위를 좁혀가며 조건 만족 여부를 탐색

✔ 장점:

- 정렬 없이 O(n)에 가까운 효율적 탐색 가능

### 4. 카운팅 배열 (Counting Array)

✔ 언제 사용?

- 데이터의 범위가 작고 정수로 제한된 경우

- 정렬이 아니라 빈도 기반 분석이 필요한 경우

✔ 장점:

- O(n)의 시간복잡도로 빈도수 확인 가능

- 정렬 없이 최소값, 최대값, 누적 분석 가능

✔ 단점:

- 메모리 낭비 가능 (값의 범위가 크면)

### 5. 트리 구조 (BST, Treemap 등)

✔ 언제 사용?

- 삽입/삭제를 자주 하면서 정렬 상태 유지가 필요할 때

- 대부분 JavaScript엔 내장 구현이 없어 직접 구현 or 외부 라이브러리 필요

✔ 장점:

- 균형 트리를 유지하면 O(log n)으로 정렬된 삽입/탐색 가능

- 중간값, 범위 탐색 등에 유리

## 정렬이 아닌 대체 방법이 더 좋은 경우

| 상황                      | 정렬 필요 없음 | 대체 방법                    |
| ------------------------- | -------------- | ---------------------------- |
| 중복만 제거하고 싶다      | ✅             | `Set`                        |
| 최댓값/최솟값만 필요하다  | ✅             | `Heap`                       |
| 특정 순위의 값만 필요하다 | ✅             | `Heap`                       |
| 빠른 존재 확인이 중요하다 | ✅             | `Map` 또는 `Set`             |
| 정렬 없이 쌍/구간/합 찾기 | ✅             | `Two Pointers`, `Prefix Sum` |
| 정수 범위가 좁다          | ✅             | `Counting`                   |

정렬은 강력하지만 느릴 수 있고, 문제의 목적을 파악하면 더 빠르고 적합한 대안이 많다.

특히 실시간 성능, 메모리 제한, 데이터 특징(정수, 범위 제한 등)을 고려하면 힙, Set, Map, 카운팅 배열 등이 훌륭한 대안이 된된다.
